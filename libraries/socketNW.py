import socket
import sys
import signal
import os

from libraries.Ticket import *


class Socket:
    listenerSocket: socket
    connection: socket


class ServerSocket(Socket):
    host = 'localhost'

    # Constructor binds the socket and listens for connections
    def __init__(self, port, queueSize):

        for response in socket.getaddrinfo(
                self.host,
                port,
                0,
                socket.SOCK_STREAM,
                0,
                socket.AI_PASSIVE):
            addressFamily, socktype, proto, canonname, sa = response

            try:
                self.listenerSocket = socket.socket(
                    addressFamily, socktype, proto)
            except socket.error as msg:
                self.listenerSocket = None
                print('[-] Socket setup failed: {0}'.format(msg))
                continue
            try:
                self.listenerSocket.setsockopt(
                    socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
                self.listenerSocket.bind(sa)
                self.listenerSocket.listen(queueSize)
                print(
                    '[+] Listening for Connections on Port: {0}...'.format(port))
            except socket.error as msg:
                self.listenerSocket.close()
                self.listenerSocket = None
                print('[-] Listen/bind failed: {0}'.format(msg))
                continue
            break
        if self.listenerSocket is None:
            print('[-] Logic Error: Could not open socket')
            sys.exit(1)

    def acceptConnections(self):
        try:
            connection, address = self.listenerSocket.accept()
            print('[+] Received connetion from: {0}'.format(address))
            self.connection = connection
            self.addr = address
        except Exception as ex:
            print('[-] Accept failed: {0}'.format(ex))

    # Sends data to client
    def sendData(self, data):
        # try:
        self.connection.sendall(data.encode('utf-8'))
        # except Exception as ex:
        # self.sendErrorAndCloseConnection(ex)
        return 0

    # Sends error data and closes the connection
    def sendErrorAndCloseConnection(self, error):
        print("[-] ERROR: {0}, Connection Closed".format(error))
        self.listenerSocket.sendall(
            "[-] ERROR: {0}, Connection Closed".format(error).encode('utf-8'))
        self.closeConnection()

    # Close Connection
    def closeConnection(self):
        print("[-] Closing Connection...")
        self.listenerSocket.close()
        self.connection.close()

    # Handles data receiving
    def receiveData(self):
        data = eval(self.connection.recv(2048).decode())
        if not data:
            raise Exception("[-] No data received")
        print("[-] Data Received: {0}".format(data))
        return data

    # Logic, processLogic is any method that receives data from the client
    def startLogic(self):
        try:
            pid = os.fork()
        except OSError:
            raise OSError("[-] Fork failed, unable to create child process")
        data = ''
        if pid == 0:

            listenerSocket.close()

            print('[+] Running...')
            self.handleClient()

            self.stopChildProcess()
        else:
            self.connection.close()

    def stopChildProcess(self):
        print('[-] Closing connection...')
        self.connection.close()
        os._exit(0)


def handleClient(self):

    ticket = []

    dataRecived = self.receiveData()

    typeOfTicket = dataRecived["typeOfTicket"]
    numberOfTickets = dataRecived["numberOfTickets"]
    identifier = dataRecived["identifier"]

    while numberOfTickets > 0:

        if typeOfTicket == 1:
            ticket.append(LottoMax())
            ticketType = "Lotto Max"

        elif typeOfTicket == 2:
            ticket.append(Lotto649())
            ticketType = "Lotto 6/49"

        elif typeOfTicket == 3:
            ticket.append(DailyGrand())
            ticketType = "Daily Grand"

        numberOfTickets -= 1

    dataToSend = dict(typeOfTicket=ticketType, numbers=[], id=identifier)
    for i in ticket:
        dataToSend["numbers"].append(i.generateNumbers())

    self.connection.sendall(str(dataToSend).encode())

    return dataToSend


class ClientSocket(Socket):

    # Constructor binds the socket and listens for connections
    def __init__(self, host, port):
        for response in socket.getaddrinfo(
                host,
                port,
                0,
                socket.SOCK_STREAM):
            af, socktype, proto, canonname, serverAddress = response
            try:
                self.listenerSocket = socket.socket(af, socktype)
            except socket.error as msg:
                self.listenerSocket = None
                print('[-] Socket setup failed: {0}'.format(msg))
                continue
            try:
                self.listenerSocket.connect(serverAddress)
            except socket.error as msg:
                self.listenerSocket.close()
                self.listenerSockets = None
                print('[-] Bind/Connect failed: {0}'.format(msg))
                continue
            break
        if self.listenerSocket is None:
            print('[-] Logic Error: Could not open socket')
            sys.exit(1)

    # Sends data to server, if failed it sends an error message to STDOUT
    def sendData(self):

        idPool = [chr(i) for i in range(ord("0"), ord("z") + 1)]
        identifier = random.sample(idPool, 6)

        dataToSend = dict(
            typeOfTicket=2,
            numberOfTickets=1,
            identifier=identifier)

        try:
            self.listenerSocket.sendall(str(dataToSend).encode('utf-8'))
        except Exception as ex:
            self.sendErrorAndCloseConnection(ex)
        return 0

    # Sends error data and closes the connection
    def sendErrorAndCloseConnection(self, error):
        print("[-] ERROR: {0}, Connection Closed".format(error))
        self.closeConnection()

    # Close Connection
    def closeConnection(self):
        print('[-] Closing connection...')
        self.listenerSocket.close()

    # Handles data receiving
    def receiveData(self):
        data = eval(self.listenerSocket.recv(2048).decode())
        if not data:
            raise Exception("[-] No data received")
        return data
